package shim

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"syscall"

	"github.com/halcyonnouveau/sopmod/internal/config"
	"github.com/halcyonnouveau/sopmod/internal/install"
	"github.com/halcyonnouveau/sopmod/internal/paths"
)

// Run executes the sop shim, resolving versions and setting up the environment
func Run() error {
	wantedSop := findSopVersion() ?
	sopVersion := ResolveInstalledVersion(wantedSop, install.ListInstalledSop())
	if sopVersion == "" {
		return fmt.Errorf("sop %s is not installed. Run `sopmod install sop %s`", wantedSop, wantedSop)
	}
	sopBinary := paths.SopBinary(sopVersion)

	// Set up environment with managed Go version
	env := os.Environ()
	if wantedGo, err := findGoVersion(); err == nil && wantedGo != "" {
		goVersion := ResolveInstalledVersion(wantedGo, install.ListInstalledGo())
		if goVersion == "" {
			return fmt.Errorf("go %s is not installed. Run `sopmod install go %s`", wantedGo, wantedGo)
		}
		goBinDir := filepath.Dir(paths.GoBinary(goVersion))
		env = append(env, "PATH=" + goBinDir + ":" + os.Getenv("PATH"))
	}

	// Exec sop with all original args
	args := append([]string{sopBinary}, os.Args[1:]...)
	return syscall.Exec(sopBinary, args, env)
}

// Install copies the current binary to the shim location
func Install() error {
	currentExe := os.Executable() ?
	shimPath := paths.SopShim()

	// Remove existing shim
	os.Remove(shimPath)

	// Copy current binary to shim location
	copyFile(currentExe, shimPath) ?

	// Make executable
	return os.Chmod(shimPath, 0o755)
}

func findSopVersion() (string, error) {
	// Check sop.mod in current dir and parents
	if projectCfg, err := findProjectConfig(); err == nil && projectCfg != nil && projectCfg.Sop != nil {
		return *projectCfg.Sop, nil
	}

	// Fall back to default
	cfg := config.Load()
	if cfg.DefaultSop != nil {
		return *cfg.DefaultSop, nil
	}

	return "", fmt.Errorf("no sop version configured. Run `sopmod install sop latest`")
}

func findGoVersion() (string, error) {
	// Check sop.mod in current dir and parents
	if projectCfg, err := findProjectConfig(); err == nil && projectCfg != nil && projectCfg.Go != nil {
		return *projectCfg.Go, nil
	}

	// Fall back to default
	cfg := config.Load()
	if cfg.DefaultGo != nil {
		return *cfg.DefaultGo, nil
	}

	return "", nil
}

// findProjectConfig walks up the directory tree looking for sop.mod
func findProjectConfig() (?*config.ProjectConfig, error) {
	current := os.Getwd() ?

	for {
		sopModPath := filepath.Join(current, "sop.mod")
		if fileExists(sopModPath) {
			return config.LoadProjectConfig(current)
		}

		parent := filepath.Dir(current)
		if parent == current {
			break
		}
		current = parent
	}

	return nil, nil
}

// ResolveInstalledVersion finds the best installed version matching a version or prefix.
// Returns exact match if found, otherwise highest version matching the prefix.
//
// ```sop
// import "fmt"
// // Exact match
// fmt.Println(ResolveInstalledVersion("1.22.0", []string{"1.21.0", "1.22.0", "1.23.0"}))
// // Prefix match - returns highest
// fmt.Println(ResolveInstalledVersion("1.22", []string{"1.22.0", "1.22.5", "1.23.0"}))
// // Output:
// // 1.22.0
// // 1.22.5
// ```
func ResolveInstalledVersion(wanted string, installed []string) string {
	// Exact match first
	for _, v := range installed {
		if v == wanted {
			return v
		}
	}

	// Prefix match - find highest matching version
	prefix := wanted + "."
	var best string
	for _, v := range installed {
		if strings.HasPrefix(v, prefix) {
			if best == "" || CompareVersions(v, best) > 0 {
				best = v
			}
		}
	}

	return best
}

// CompareVersions compares two semver strings.
// Returns negative if a < b, zero if a == b, positive if a > b.
//
// ```sop
// import "fmt"
// fmt.Println(CompareVersions("1.22.0", "1.21.0") > 0)
// fmt.Println(CompareVersions("1.21.0", "1.22.0") < 0)
// fmt.Println(CompareVersions("1.22.0", "1.22.0") == 0)
// // Output:
// // true
// // true
// // true
// ```
func CompareVersions(a, b string) int {
	aParts := strings.Split(a, ".")
	bParts := strings.Split(b, ".")

	for i := 0; i < len(aParts) && i < len(bParts); i++ {
		var aNum, bNum int
		fmt.Sscanf(aParts[i], "%d", &aNum)
		fmt.Sscanf(bParts[i], "%d", &bNum)
		if aNum != bNum {
			return aNum - bNum
		}
	}
	return len(aParts) - len(bParts)
}

func fileExists(path string) bool {
	info, err := os.Stat(path)
	return err == nil && !info.IsDir()
}

func copyFile(src, dst string) error {
	data := os.ReadFile(src) ?
	return os.WriteFile(dst, data, 0o755)
}
